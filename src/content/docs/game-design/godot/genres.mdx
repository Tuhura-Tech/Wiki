---
title: Genres
description: This page for Godot is dedicated to making specific types of games. Just the basics of everything, it teaches a wide variety, so not a first-person shooter *and* a third-person shooter.
sidebar:
    order: 3
---

This page is for creating specific types of games in Godot. This guide will assume you have gone through the basics page and understand the core concepts.

We won't go through a lot of the simple things like where to find buttons, how to set up a project, etc.

Also, all nodes will be renamed appropriately in all screenshots, they will not be the original names of the nodes. We recommend you rename your nodes as well.

## Universal features

To skip explaining this throughout every genre, there are some unchanging features nearly every single game has.

Primarily these will be flexible and done in different ways for the game, and some artful games totally forgo some, or any, of these staples of the medium.

But this isn't about how there always has to be a character controller of some variety. Character controllers come in all shapes and sizes.

This is about things like the main menu, settings, mapping inputs, and things of the sort. These are very rarely done differently, aside from the layout and aesthetics.

### Main Menu

Main menus are nigh universal traits. They are usually the same formula copied and slightly twisted to fit the aesthetic.

#### Setting up

Make a new scene and make the root node a **Control** node, listed as **User Interface**.

![Create root node section of Godot with User Interface highlighted](/src/assets/godot/genres/UserInterfaceRootNode.png)

For this, we'll need the node tree:
- **Control** - Root node
	- **ColorRect** - The background
	- **RichTextLabel** - The title
	- **VBoxContainer** - Holds the buttons
		- **Button** - Start button
		- **Button** - Settings button
		- **Button** - Quit button


#### Anchors

Tons of people have differently sized screens; not everyone has a 16:9 aspect ratio monitor. For this reason we need anchors, it's similar to designing a responsive website.

Select your **ColorRect** first. On the right of your toolbar at the top of the viewport, there should be the option to set the anchor preset.
![Scene with "Your beautiful game" as title, a start, settings, and menu button below it, and with the anchor presets menu open](/src/assets/godot/genres/AnchorPresets.png)

The background **ColorRect** should be set to **Full Rect** so it covers the default background and resized to cover the entire background no matter the aspect ratio. Feel free to change the **ColorRect**'s color.

The **RichTextLabel** should bCleanup e connected to the part of the screen they'll move with when the screen is resized. In the anchor preset menu, select the closest one to where you want it to be, then move the nodes to be roughly where you want them to be.

Test out moving them around by selecting your **Control** node and resizing it with the orange dots.

In the inspector of **RichTextLabel**, set the text to the title of your game. Next, go to **Control > Theme Overrides > Colors > Default Color** and turn it on. Your text may have been white on the white background and not visible before, this will change it to the black color. You can change the value of the default color. Finally, in **Control > Theme Overrides > Font Sizes > Normal Font Size**, turn it on and make the text larger.

Do the same things for your three buttons. You can select all three buttons with shift/ctrl + click and do them all at once. The text will need to be set separately.

The **VBoxContainer** node stacks all of its children nodes in a **V**ertical **Box**.

Make it wide and tall enough to contain the buttons, anchor and size it properly. Your buttons should be there.

User interfaces in games are a bit finicky due to the fact that not all screens are built equal. Some people have ultra-wide monitors, some people play games on old CRT screens. Who knows, maybe someone will play your game in their brain one day. Making your game accessible is paramount.

#### Interaction

It's good practice to separate functions into as many files as you can. This is helpful for keeping tidy, working with people using Git, help remind future-you what now-you were thinking, and just generally be easier. It's for these reasons, we'll use a short and separate script for each of the buttons. And just so we don't clutter up your scripts folder and we'll never touch these again, we'll use built-in scripts which are stored in the `.tscn` file for your scene instead of a separate `.gd` file.

Give your start button a script, toggle built-in, and make it. Delete everything other than `extends Button`. Connect the start button's `pressed()` signal to its own script and set the function's body to `get_tree().change_scene_to_file("res://scenes/main_menu.tscn")`. Replace `res://scenes/main_menu.tscn` with the path to the first level, the main scene, or whatever scene you would normally open to play your game. If you're starting with just a main menu you can set this later. Make sure to press play or **F5** and set the current scene as the scene it loads up when you play the game.

:::note[Faster loading]
It's a good idea to use `get_tree().change_scene_to_packed()` instead. The only difference is you need a global variable along the lines of `var main_scene = preload("res://scenes/main_menu.tscn")`. Of course with the main menu scene switched out for your game's starting scene. Then give that as a variable in the method in your function body with `get_tree().change_scene_to_packed(main_scene)`.

This causes Godot to load the scene into memory before you press the button, instead of loading the scene after you press the button. It's faster and more responsive for your player.
:::

Your quit button is just as easy. Make a script, connect the signal. This time in the function body give it `get_tree().quit()`.

The settings button requires a settings menu.

### Settings

If you just made your main menu with the above guide, click the eye icon on your button container and the title label.

#### Setting up

As a child of your **Control** node, add **TabContainer**. We will provide examples for changing video, audio, and controls. But you will have to think of and provide settings for the gameplay since it's all about your unique game.

Make sure to anchor your **TabContainer** to **Full Rect** so it takes up the whole screen.

Add this as a child of the root node:
- **TabContainer** - Contains the tabs
	- **TabBar** - Video tab
		- **VBoxContainer** - Lists the options vertically
			- **HBoxContainer** - Holds the label and the option for the setting
				- **Label** - Tells the name of the setting
				- **VSeparator** - Vertical separator between the label and the option
				- **OptionButton** - Lets the user decide between 2D MSAA
				- **OptionButton** - Lets the user decide between 3D MSAA
				- **CheckBox** - Lets the user decide if to use screen space FXAA
				- **Checkbox** - Lets the user decide if to use TAA
	- **TabBar** - Audio tab
		- **VBoxContainer** - Lists the options vertically
			- **HBoxContainer** - Holds the label and the option for the setting
				- **Label** - Tells the name of the setting
				- **VSeparator** - Vertical separator between the label and the option
				- **HSlider** - Lets the user change the volume
	- **TabBar** - Gameplay tab
	- **TabBar** - Controls tab
		- **VBoxContainer** - Lists the options vertically
			- **HBoxContainer** - Holds the label and the option for the setting
				- **Label** - Tells the name of the setting
				- **VSeparator** - Vertical separator between the label and the option
				- **Button** - Lets the user change the related button

A lot of this is very similar. You can just make one **TabBar** and its children, then copy-paste it onto the **TabContainer** three times. If you do this, make sure to change the related **TabBar** names and the option nodes.

You must rename the **TabBar** nodes to change the title of the tabs.

#### Video: Anti-Aliasing

Godot has some good documentation for both [2D](https://docs.godotengine.org/en/stable/tutorials/2d/2d_antialiasing.html) and [3D](https://docs.godotengine.org/en/stable/tutorials/3d/3d_antialiasing.html) anti-aliasing. They have some good diagrams showing what it's like with and without anti-aliasing.

There are many ways of combating this effect, Godot has a few built-in. Sometimes you may not want to fight the effect at all and just have it to give a retro-style.

We'll let the player choose between the built-in Godot ones.

##### Making the option

Go to the inspector for each MSAA nodes and add elements to the **Items** array property. Give it the options Disabled, 2x, 4x, and 8x. Of course, you can remove the irrelevant 2D or 3D node if you know what your game is going to be.

If you plan to have the default settings be more than just all disabled, you can change the **Selected** property for the **OptionButton**s, and the **Button Pressed** property for the **CheckBox**s to match your default.

Add a script to the **HBoxContainer** on the video tab and call it something like `setting_anti_aliasing.gd` in a scripts folder.

Navigate to **Project > Project Settings... > Rendering > Anti Aliasing**. This is where you can see all the options. You might recall you made two **CheckBox**s, but this screen has only one and three **OptionButton**s. Well if you select **Screen Space AA** you can see there are only **Disabled** and **FXAA**.

From here you can right-click and copy the path to the setting, this is what we'll use to set the setting.

Connect the `item_selected(index: int)` and the `toggled(toggled_on: bool` signals from all four option nodes.

Finally, use the **RenderingServer** to change the display. `RenderingServer` has the four functions we need, which you can look up with the **Search Help** button or see below. It requires the viewport RID which you can get with `get_viewport().get_viewport_rid()`.

The final hiccup will be with screen space anti-aliasing since it's technically an array instead of a boolean, even though it just has **Disabled** and **FXAA** as options. For this you can just type-cast the `bool` to `int` using `int(from: bool)` to make `true` into 1 and `false` into 0.

All in all, your script should look something like:

```gdscript
extends HBoxContainer


func _on_msaa_2d_item_selected(index):
	RenderingServer.viewport_set_msaa_2d(get_viewport().get_viewport_rid(), index)


func _on_msaa_3d_item_selected(index):
	RenderingServer.viewport_set_msaa_3d(get_viewport().get_viewport_rid(), index)


func _on_fxaa_toggled(toggled_on):
	RenderingServer.viewport_set_screen_space_aa(get_viewport().get_viewport_rid(), int(toggled_on))


func _on_taa_toggled(toggled_on):
	RenderingServer.viewport_set_use_taa(get_viewport().get_viewport_rid(), toggled_on)
```

#### Audio: Master volume

Audio in Godot goes through buses. When adding an **AudioStreamPlayer** or the 2D/3D equivalent, it's going through the custom bus set for it, then to the master bus. If no custom bus is set, it just goes through the master bus.

At the bottom of Godot you can switch to the **Audio** dock, this is what it looks like by default:
![Default audio dock in Godot](/src/assets/godot/genres/Audio.png)

When adding audio you can make custom buses and route the audio through them, then change their volume with new sliders like the one we're about to make for the master bus.

This one is simple, after changing your label to say something like "Master", start with a single script on the **HSlider**.

Connect its own `drag_ended` signal to itself.

In the Inspector set the **Min Value** to 0, **Max Value** to 1, and step to 0.1. Also set **Layout > Custom Minimum Size**'s x value to something like 300px, so the slider is wide.

Then, in your `_on_value_changed` function, add the line `AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Master"), linear_to_db(value))`.

That's it.

:::note[Decibels and linear_to_db]
The reason you need to use `linear_to_db(value)` is because the decibel (db) measurement of volume is not linear. The built-in `linear_to_db` function takes a number from 0 to 1 and converts it to decibels.

The rest of the code is just getting the right properties to set.
:::

#### Controls: Changing Input Button

First, make sure you have custom input in **Project > Project Settings... > Input Map** to change.

Change your **Label** to the name of the action you want to change, and the **Button**'s text to something like "Change input".

Give the **Button** a script:

```gdscript
extends Button

var getting_input: bool = false


func _on_pressed():
	getting_input = true
	text = "Press key..."


func _input(event):
	if getting_input and not event is InputEventMouse:
		set_button(event)


func set_button(button: InputEvent) -> void:
	getting_input = false
	text = "Change input"
	InputMap.action_erase_events("your_action")
	InputMap.action_add_event("your_action", button)
```

Connect the **Button**'s `pressed` signal to itself.

It's a relatively simple script, just using `Input`, `InputMap`, `InputEvent` and their related functions to change things.

This will remove all the events related to the action and make the next pressed button the event for the action. It's cutting out mouse events because moving your mouse or left-clicking isn't very likely to be something you want to change, but feel free to modify the `not event is InputEventMouse` to something like `not event is InputEventMouseMotion` to allow mouse buttons to be bound.

### Singleton

Almost every game needs a singleton of some variety. The Godot docs have a [good guide](https://docs.godotengine.org/en/stable/tutorials/scripting/singletons_autoload.html) on how to make a singleton and what one is.

#### What is a Singleton?

To put it in simple terms, singletons contain a piece of data that any part of your game can access at any time.

Storing your player's health in the player script isn't very good if other scenes, like an enemy, need to get the player's health and modify it regularly. Often it's slower to constantly be getting the node tree, and then finding the player node, and then getting the variable and changing it. It can cause unforseen bugs and just be a mess. So we use singletons because it's quick, easy, efficient, and just better.

Another benefit is that they aren't part of the main game, they are seperate. So even if you switch between levels, characters, menus, or whatever else you have, it'll always be the same. Never changed unless a part of the game changes it.

However, this means if you store your player's health in a singleton, it'll need to be manually reset. For example, when restarting the level because a player died you'll also need to reset the health, rather than just reinstantiating the player with their original health data.

#### Making a Singleton

To make a singleton, make a new script in the **FileSystem** dock, in your scripts folder.

Go to **Project > Project Settings... > Autoload** and click the folder icon. Add your new script to the autoload.

Name it something like **Global** or **Singleton**, so that you always know you can get the globally accessed variables by using `Singleton.player_health`. All you need to do to make the variable accessible, in that way, is add the variable to the `singleton.gd` or whatever file you made autoload.

## Bullet Heaven

Bullet heaven games are the opposite of the ever-popular bullet hell genre.

The player slowly accumulates a variety of abilities that activate automatically and fire an absurd amount of bullets at an equally absurd amount of enemies that slowly advance towards the player.

Bullet heaven games are usually from a top-down perspective.

The genre initially got popular from the Unity game Vampire Survivors.  
Although one of the most well-known Godot games, Brotato, has seen a good amount of fame after the popularity of Vampire Survivors brought attention to the concept of a bullet heaven.

For this we will make a simple 2D top-down character controller. A selection of abilities that fire projectiles periodically. Enemies that spawn outside of the screen and then slowly advance towards the player. Along the way we'll also need a health and score system.

### Top-Down 2D Character Controller

As seen in the [basics guide](../basics), the built-in Godot **CharacterBody2D** template is a side-on character controller.

Bullet heaven games are typically top-down, so let's make a top-down 2D character controller.

#### Setting Up

The player doesn't need a floor to stand on, so we don't need to make a 2D scene. You can just start with making a scene with the root node **CharacterBody2D**.

Make the following scene:
- **CharacterBody2D**
	+ **CollisionShape2D** - Set shape to **New RectangleShape2D**
	+ **Sprite2D** - Set texture to **New PlaceholderTexture2D**
	+ **Camera2D**

Make the player's collider and sprite about an eighth the size of the camera's size, and a square. You want enough room between your player and the edge of the screen so they have time to react to enemies.

Set the **CharacterBody2D**'s **Motion Mode** property to **Floating**. Grounded is for 2D side-on games, floating is for top-down.

Enable the camera's **Position Smoothing** property so it's clear if the player is moving or not.

Add up, down, left, and right to the **Input Map**.

Give the player the defult script, we'll modify it.

Since we're editing the player scene instead of the main scene the actual game is going to run in, when you want to run your game use **F6** instead of **F5**, or the **Run Current Scene** button instead of the **Run Project** button.

#### Changing the script

Before anything else give this script the class name **Player**. The enemies will also be **CharacterBody2D** so later when we make checks if we check a body against **CharacterBody2D** it'll return true for players and enemies, when we might only want enemies or the player.  
To give the script the class name, below `extends CharacterBody2D`, add `class_name Player`.

Then, delete the `gravity` variable from the top of the script and then the section changing the y velocity based on gravity and jumping. There is no traditional gravity or jumping in top-down games.

The dafault script for a **CharacterBody2D** has this section to move the player:

```gdscript
# Get the input direction and handle the movement/deceleration.
# As good practice, you should replace UI actions with custom gameplay actions.
var direction = Input.get_axis("ui_left", "ui_right")

if direction:
	velocity.x = direction * SPEED
else:
	velocity.x = move_toward(velocity.x, 0, SPEED)

move_and_slide()
```

The `Input.get_axis` function is essentially a shorthand for getting the action strength of each action and taking it away from one another. So it says in the documentation if we hold ctrl and click on `get_axis`:

```
float get_axis(negative_action: StringName, positive_action: StringName) const

Get axis input by specifying two actions, one negative and one positive.

This is a shorthand for writing Input.get_action_strength("positive_action") - Input.get_action_strength("negative_action").
```

The action strength is calculated by how far down an action is pressed. Typical keyboards will not have action strength being sent. It's useful for joysticks, Hall Effect keyboards, and a few other niche use-cases. There is no four-directional `get_axis` so we'll have to use `get_axis` twice, once for the x and once for the y axis.

Change the `direction` variable to `x_direction`, and replace the UI actions, like the template suggests, with your own left and right actions.
Make a second `y_direction` variable with your up and down actions.

Change the default if-else statement to use `x_direction` instead of `direction`, and then copy paste it so that there's also one for `y_direction`.

Your script should look something like:

```gdscript
func _physics_process(_delta):
	var x_direction = Input.get_axis("left", "right")
	var y_direction = Input.get_axis("up", "down")
	
	if x_direction:
		velocity.x = x_direction * SPEED
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)
	
	if y_direction:
		velocity.y = y_direction * SPEED
	else:
		velocity.y = move_toward(velocity.y, 0, SPEED)
	
	move_and_slide()
```

Run your game with **F6** or **Run Current Scene** since this isn't the main game scene.

If you've done all correctly, it should look like your player is moving. Make sure the camera's position smoothing is enabled. Otherwise, when your player moves, the camera also moves perfectly with them. It results in looking like the player is perfectly still.

### Enemies

Enemies in bullet heaven game's enemies are usually very simple. The difficulty comes from just how many of them there are and having to duck and dodge through the hoards while your weapons go to work.

Typically, there are a few types. But since most of the variation comes from just switching up how much health they have, how big their hitbox is, and other minor things you can make new inhereted scenes later after we build our basic enemy.

Since we need to test out the enemy scene in conjunction with the player scene, make a `main.tscn` scene with a **Node2D** root node.

If you pressed used **F5**/**Run Project** instead of **F6**/**Run Current Scene** for your player and set your main scene to be the player scene, go to **Project > Project Settings... > Run** and change the main scene to your new scene.

Use the chain-looking button next to the **Add Child Node** button in the **Scene** dock to instantiate your player scene as a child of your **Node2D** root node.

#### Setting Up

Make a new scene with the root node **CharacterBody2D** and call it something like `enemy.tscn`.

Give the **CharacterBody2D** the usual **CollisionShape2D** and **Sprite2D** children with the usual **RectangleShape2D** and **PlaceholderTexture2D** shape and texture. Size them to be about the same size as the player, but slightly smaller so we can fit more in and somewhat visually distinct them from the player.

Set the **CharacterBody2D**'s **Motion Mode** property to **Floating** like you did with the player.

Instantiate your enemy scene in your main scene and move the instantiated enemy away from the player. Run your game with **F5**/**Run Project** and set the main scene as the main scene of the project if you haven't already. Now you have a point in which you can tell if your player is actually moving or not. The enemy does nothing without a script so let's give it one.

Finally, this enemy is going to need a way to reduce the player's health. However, the player has no health variable yet. In your singleton, which you can find how to make one above in the **Universal Features** section, add a new `player_health` variable and set it to 100.

#### Script

Get rid of everything below the line `func _physics_process(delta):` and above `move_and_slide()`, but not those lines, and delete the `gravity` and `JUMP_VELOCITY` variables.

Give this script the class name `Enemy` with `class_name Enemy` below `extends CharacterBody2D`.

Reduce the speed from `300.0` to something like `100.0` or `150.0`. Enemies need to be slower than the player in bullet hell games because the challenge is from avoiding hoards of them while your weapons work. Not from conserving health for when an enemy unfairly tackles you out of nowhere and you can't do anything to get away from it until your weapons finally take it down.

##### Moving Towards the Player

To move towards the player, we're going to need to find the player.

In your singleton add an onready variable that holds the player.

In your player's script add the built-in `_ready()` function and set the Singelton's player_node variable to the player itself.

The singleton script should look something like this:

```gdscript
extends Node

var player_health: int = 100
@onready var player_node: Player
```

The player script's ready function should look similar to:

```gdscript
func _ready():
	Singleton.player_node = self
```

:::note[Static typing]
Statically typing means that you are making sure that a variable stays as the type you want it to be. For example, if you don't want an integer (a whole number, without decimal palces) to ever have decimal places, statially type the variable with `: int` after the name and before setting the value.

This is very, very useful for debugging later on, and making sure you don't make a mistake.

The reason we can statically type with `: Player` on the `player_node` variable is because we set the class name of the player script to be `Player`. In this case, it'll help ensure we don't accidentally set any other nodes to also be in the "player" group and also help Godot's code editor autocomplete any variables, functions, or signals we might have in the player script.

Other common use-cases are the basic types like `bool` (boolean, true or false), `float` (floating-point number, number with possible decimal places), `String` (text, defined with "quotes around it, like this"), or to set variables, like the `player_node` variable, with complex types like **CharacterBody2D** to have access to code-completion in the Godot editor.
:::

Now, to finally edit the enemy script itself.

Before `move_and_slide()` add the *totally* simple line:

```gdscript
velocity = global_position.direction_to(Singleton.player_node.global_position) * SPEED
```

Breakdown of this line:

First, with `Singleton.player_node.global_position` we get the player's global position, which is a Vector2 since it's the x and y position.

Next, we use `global_position.direction_to()` to get the direction to the player from the `global_position` of the enemy. It gets this direction in a Vector2, in which both x and y add up to 1. We call this a normalized vector since it's used for simple directions instead of anything like magnitude or position or anything else.

Then, we multiply that normalized vector with `SPEED` so now the vector that adds up to 1 in the direction of the player, will multiply up to 1 times the value of speed to also indicate how fast the player should move.

Since we now have a variable that says the speed in which the player should move and the direction it should be moving in, in the form of a Vector2, we can make that the velocity of the enemy.

:::note[Vector math]
Vector math is a large part of making any video game, but it's not very hard after you get the basic idea that a vector can represent a lot of things and begin to understand that. Godot's docs have a genuinely wonderful page about vector math.

[Check it out here!](https://docs.godotengine.org/en/stable/tutorials/math/vector_math.html) Please do read it, vectors are essential to any game developer in any engine. It's not very long but it is quite a bit to wrap your mind around.
:::

Anyway, the enemy should now move towards the player. Hooray!

##### Dealing Damage

Start by making a damage constant value at the top of your script next to the speed constant. Make it something like 5 and name it something in all caps since it's a constant like `DAMAGE`.

Every time you call `move_and_slide()` it's taking the velocity variable of the **CharacterBody2D**, then moves the player that much, then checks for collisions and slides the player along any collisions it makes, then it stores what collisions have been made.

If we look at the **CharacterBody2D** in **Search Help** we can see a list of properties and methods that might be helpful:

```gdscript
void apply_floor_snap ( )

float get_floor_angle ( Vector2 up_direction=Vector2(0, -1) ) const
Vector2 get_floor_normal ( ) const
Vector2 get_last_motion ( ) const
KinematicCollision2D get_last_slide_collision ( )
Vector2 get_platform_velocity ( ) const
Vector2 get_position_delta ( ) const
Vector2 get_real_velocity ( ) const
KinematicCollision2D get_slide_collision ( int slide_idx )
int get_slide_collision_count ( ) const
Vector2 get_wall_normal ( ) const

bool is_on_ceiling ( ) const
bool is_on_ceiling_only ( ) const
bool is_on_floor ( ) const
bool is_on_floor_only ( ) const
bool is_on_wall ( ) const
bool is_on_wall_only ( ) const
bool move_and_slide ( )
```

Here we can see there's the `get_slide_collision` and `get_slide_collision_count` methods. If we look at the description of `get_slide_collision` there's an explanation and a block of code showing us how to use both methods in conjunction to go through all of the collided objects.

If you're eagle-eyed you might have also spotted the `get_last_slide_collision` method. We don't want to use this because it only returns the last collision made, not all of the collisions made. With how many enemies the game has it's not going to be unlikely that the enemy will hit the player and then slide into another enemy in the same frame. Just checking the last slide collision won't work, so we'll use the other two slide collision methods to check every collision made.

Use the provided code-block in the `get_slide_collision` description and modify it so that instead of the print statement in the for-loop, add this:

```gdscript
if collision.get_collider() is Player:
	Singleton.player_health -= DAMAGE
	queue_free()
```

For this simple game we're just going to run `queue_free()` so the player does damage and then disappears so the next enemy can deal damage. If we didn't do this it would deal damage every single frame the player is touching the enemy and it would deal insane amounts of damage very quickly. If you want, you can use a **Timer** node, set it to one shot, replace `queue_free()` with starting the timer, and then check if the timer is stopped as part of the `if collision.get_collider() is Player:` if statement. This would stop the enemy from doing insane damage and limit it to once whenever timer's value was set at.

In theory, what we have now though should work. Of course, we don't have anything to tell us how much health the player has so let's quickly make death and a health bar.

### Health and Death

#### Health Bar

Let's start with a simple health bar.

In your player scene add a **ProgressBar** as a child of the root node. Position it above the player and make it wider so you can see the bar's progress.

Set the **Value** property of the **ProgressBar** to 100, this is your health bar.

Get the health bar in your player's script by opening the player's script, dragging the node to the top of the script where you want the variable, and before you release the left mouse button hold control. This will make the entire onready variable for you.

At the beginning of `_physics_process(delta)` add a line that sets the **ProgressBar**'s value property to the same value as your singleton's player health value. This is assuming your maximum health is 100. If it's something else you need to change the **Max Value** property on your health bar.

#### Restarting Game

Next comes the death.

Make a new constant for your player's max health. This is just so we can reset the health to this value. It's good practice to not have random numbers laying around your scripts and instead use constants with descriptive names.

Add in the `_physics_process(delta)` function to your singleton.

Give it a simple if statement checking if the player's health is below or equal to 0.

Inside that, set your player's health to the max health constant you made before. Then run `get_tree().reload_current_scene()`. It's important you do it in that order, reloading the scene could stop the script from running in other circumstances and not reset the player's health. It shouldn't in this case since this is an autoload script and won't be reset, but it's still best practice to reload or change scenes after doing all other reset or changing operations.

Since we set the `player_node` variable during the player's `_ready()` function, we don't need to set it again. It's going to change the variable when the node is made and enters the scene tree.

Booyah, the player can now die!

## Rhythm

## 3D Racer

## First Person Shooter

## Tower Defense